<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yriuns.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="据说，OceanBase的CTO杨传辉曾经说过：“构建一个分布式数据库存储系统是比较简单的，上层一套raft一致性协议，下层接一个RocksDB引擎，一周时间就能搞定，难得是如何保证系统在后续的运行中性能稳定且可靠”。且不论一周时间到底够不够，不可否认的是，Raft协议的出现使得构建一个分布式系统简单了许多。 但即使Raft作者把各种工程问题解决之道都写在了他的博士论文里，真正去实现一个高效稳定的">
<meta property="og:type" content="article">
<meta property="og:title" content="braft&#x2F;\*非官方\*&#x2F;实践指南">
<meta property="og:url" content="https://yriuns.github.io/2022/01/08/braft-in-action/index.html">
<meta property="og:site_name" content="Yriuns&#39; Blog">
<meta property="og:description" content="据说，OceanBase的CTO杨传辉曾经说过：“构建一个分布式数据库存储系统是比较简单的，上层一套raft一致性协议，下层接一个RocksDB引擎，一周时间就能搞定，难得是如何保证系统在后续的运行中性能稳定且可靠”。且不论一周时间到底够不够，不可否认的是，Raft协议的出现使得构建一个分布式系统简单了许多。 但即使Raft作者把各种工程问题解决之道都写在了他的博士论文里，真正去实现一个高效稳定的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yriuns.github.io/images/braft-in-action/raft.png">
<meta property="og:image" content="https://yriuns.github.io/images/braft-in-action/Linearizability.png">
<meta property="article:published_time" content="2022-01-08T11:40:23.000Z">
<meta property="article:modified_time" content="2022-01-19T11:46:29.361Z">
<meta property="article:author" content="Yriuns">
<meta property="article:tag" content="Raft">
<meta property="article:tag" content="分布式系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yriuns.github.io/images/braft-in-action/raft.png">

<link rel="canonical" href="https://yriuns.github.io/2022/01/08/braft-in-action/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>braft/\*非官方\*/实践指南 | Yriuns' Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yriuns' Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">来都来了，收藏一下吧</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yriuns.github.io/2022/01/08/braft-in-action/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yriuns">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yriuns' Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          braft/\*非官方\*/实践指南
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-08 19:40:23" itemprop="dateCreated datePublished" datetime="2022-01-08T19:40:23+08:00">2022-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-19 19:46:29" itemprop="dateModified" datetime="2022-01-19T19:46:29+08:00">2022-01-19</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>据说，OceanBase的CTO杨传辉曾经说过：“构建一个分布式数据库存储系统是比较简单的，上层一套raft一致性协议，下层接一个RocksDB引擎，一周时间就能搞定，难得是如何保证系统在后续的运行中性能稳定且可靠”。且不论一周时间到底够不够，不可否认的是，Raft协议的出现使得构建一个分布式系统简单了许多。</p>
<p>但即使Raft作者把各种工程问题解决之道都写在了他的博士论文里，真正去实现一个高效稳定的Raft库仍然要费很多心思。此外，库的使用者也必然会遇到各种意想不到的问题。</p>
<p>由于工作的关系，笔者深度使用了braft一段时间。总体来说braft是一个完成度很高的工业级实现，省去了团队不少开发及测试的时间。但是当然也遇到了不少坑。因此本文将分享一些笔者在使用/魔改braft的一些小经验，希望能让你少踩点坑。</p>
<span id="more"></span>

<p>如下图所示，使用Raft的系统可以分为两大部分：Raft算法和状态机。简单来说，Raft算法约定了如何选出leader、日志如何进行复制、日志什么时候被认为committed，通过这些约定保证了日志的一致性；而状态机则是在得知日志commit后按照日志内容修改自身状态(即日志apply到状态机)。</p>
<p><img src="/images/braft-in-action/raft.png" alt="raft流程图"></p>
<p>绝大多数的Raft库都是异步的，即日志的复制与日志的apply互相不阻塞。因此，使用Raft的过程中要时刻意识到状态机的状态有可能“不够新”。例如某条日志实际上已经达成一致很久了，状态机却还没有进行相应的更新，这可能是因为：1. 它还未得知这条日志达成一致这个信息；2. 或是负责更新状态机的线程还未处理到这条日志。</p>
<h2 id="基本使用姿势"><a href="#基本使用姿势" class="headerlink" title="基本使用姿势"></a>基本使用姿势</h2><p>作为Raft论文的忠实实现，braft自然也为用户提供了日志与状态机两个结构。</p>
<ol>
<li>Raft节点<code>braft::Node</code>。用户需要构造出<code>braft::Node</code>，用以提交日志，即调用<code>void apply(const Task&amp; task)</code>接口（个人认为应该把<code>apply</code>改名为<code>propose</code>）。</li>
<li>状态机。用户需要继承<code>braft::StateMachine</code>，实现状态机的各个接口以完成自己的业务逻辑，其中<code>on_apply</code>是必须实现的。如果一切顺利，braft会<strong>串行地</strong>调用状态机的<code>on_apply</code>接口，先前通过<code>apply</code>接口提交的日志就能从<code>on_apply</code>中取出。</li>
</ol>
<p>有了这两个接口，就已经能实现一个简单的分布式服务了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/baidu/braft/blob/master/example/atomic/server.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Atomic</span> :</span> <span class="keyword">public</span> braft::StateMachine &#123;</span><br><span class="line">    <span class="comment">// RPC接口: 读(并发调用)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">const</span> ::example::GetRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">             ::example::AtomicResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">             ::google::protobuf::Closure* done)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">apply</span>(OP_GET, request, response, done);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC接口: 写(并发调用)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">const</span> ::example::ExchangeRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                  ::example::AtomicResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                  ::google::protobuf::Closure* done)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">apply</span>(OP_EXCHANGE, request, response, done);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读写都提交到raft, 利用raft做串行化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(AtomicOpType type, <span class="keyword">const</span> google::protobuf::Message* request,</span></span></span><br><span class="line"><span class="params"><span class="function">               AtomicResponse* response, google::protobuf::Closure* done)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        task.data = ...; <span class="comment">// 用户的数据</span></span><br><span class="line">        <span class="keyword">return</span> _node-&gt;<span class="built_in">apply</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态机接口(被braft单线程调用)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_apply</span><span class="params">(braft::Iterator&amp; iter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; iter.<span class="built_in">valid</span>(); iter.<span class="built_in">next</span>()) &#123;</span><br><span class="line">            butil::IOBuf data = iter.<span class="built_in">data</span>(); <span class="comment">// iter.data() 就是前面的 task.data</span></span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> OP_GET:</span><br><span class="line">                <span class="comment">// 读 + 回包</span></span><br><span class="line">                <span class="built_in">get_value</span>(data, request, response);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_EXCHANGE:</span><br><span class="line">                <span class="comment">// 写 + 回包</span></span><br><span class="line">                <span class="built_in">exchange</span>(data, request, response);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读请求优化"><a href="#读请求优化" class="headerlink" title="读请求优化"></a>读请求优化</h2><p>很显然，只读请求也需要经历一轮raft协议是非常低效的做法。对于只读请求来说，要想实现线性一致性并不需要这种完全串行化的做法。</p>
<p>Raft作者给出了两个方案(见博士论文第6.4节 Processing read-only queries more efficiently)：Read Index与Lease Read。它们的核心思想都是只要能确认自己是leader &amp;&amp; 自己的状态机足够新，就可以直接读取状态机里的值而无需通过Raft Log。</p>
<p>那么如何在braft中实现呢？</p>
<blockquote>
<p>braft目前还不提供Read Index，故不予考虑该方案</p>
</blockquote>
<h3 id="尝试1-利用on-leader-start来实现"><a href="#尝试1-利用on-leader-start来实现" class="headerlink" title="尝试1. 利用on_leader_start来实现"></a>尝试1. 利用<code>on_leader_start</code>来实现</h3><p>稍加浏览，不难发现<code>braft::StateMachine</code>提供了leader相关的接口可供覆写：</p>
<ul>
<li><code>virtual void on_leader_start(int64_t term);</code></li>
<li><code>virtual void on_leader_stop(const butil::Status&amp; status);</code></li>
</ul>
<p>那么自然我们想到一个做法：<code>on_leader_start</code>时标记自己是leader，可以直接处理读请求；<code>on_leader_stop</code>时标记自己是follower，不再处理任何请求。</p>
<p>braft官方给出的example也是这么写的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/baidu/braft/blob/master/example/counter/server.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> :</span> <span class="keyword">public</span> braft::StateMachine &#123;</span><br><span class="line">    <span class="comment">// RPC接口: 写(并发调用)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fetch_add</span><span class="params">(<span class="keyword">const</span> FetchAddRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                   CounterResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                   google::protobuf::Closure* done)</span> </span>&#123;</span><br><span class="line">        <span class="function">brpc::ClosureGuard <span class="title">done_guard</span><span class="params">(done)</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int64_t</span> term = _leader_term.<span class="built_in">load</span>(butil::memory_order_relaxed);</span><br><span class="line">        <span class="comment">// 不是leader，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (term &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">redirect</span>(response);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// leader校验通过，提供写服务</span></span><br><span class="line">        <span class="keyword">return</span> _node-&gt;<span class="built_in">apply</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC接口: 读(并发调用)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(CounterResponse* response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不是leader，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">is_leader</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">redirect</span>(response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// leader校验通过，直接读取状态机的当前值</span></span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(<span class="literal">true</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_value</span>(_value.<span class="built_in">load</span>(butil::memory_order_relaxed));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">is_leader</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _leader_term.<span class="built_in">load</span>(butil::memory_order_acquire) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从此刻起，认为自己是leader</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_leader_start</span><span class="params">(<span class="keyword">int64_t</span> term)</span> </span>&#123;</span><br><span class="line">        _leader_term.<span class="built_in">store</span>(term, butil::memory_order_release);</span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Node becomes leader&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从此刻起，认为自己不是leader</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_leader_stop</span><span class="params">(<span class="keyword">const</span> butil::Status&amp; status)</span> </span>&#123;</span><br><span class="line">        _leader_term.<span class="built_in">store</span>(<span class="number">-1</span>, butil::memory_order_release);</span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Node stepped down : &quot;</span> &lt;&lt; status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，眼尖的读者可能已经发现，这样写有可能导致stale read。<br>虽然<code>on_xxx</code>系列接口之间是串行的，但<code>get</code>接口与它们却是完全并行的。<br>假设节点A在<code>t0</code>时刻<code>on_leader_start</code>，<code>t1</code>时刻变为follower，<code>t2</code>时刻才<code>on_leader_stop</code>。那么在<code>t1~t2</code>期间<code>get</code>请求全都能成功，实际上不应该成功。<br>更糟糕的是<code>t1~t2</code>这个时间窗口可能任意长（比如<code>on_leader_stop</code>卡住了）。</p>
<h3 id="尝试2-利用leader-lease实现lease-read"><a href="#尝试2-利用leader-lease实现lease-read" class="headerlink" title="尝试2. 利用leader lease实现lease read"></a>尝试2. 利用leader lease实现lease read</h3><p>既然问题出在<code>on_leader_stop</code>的调用没那么及时，那我校验leader lease来保证自己是leader总没问题了吧。于是加了个条件，代码变成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_leader</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> _leader_term.<span class="built_in">load</span>(butil::memory_order_acquire) &gt; <span class="number">0</span> &amp;&amp; _node.<span class="built_in">is_leader_lease_valid</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很可惜，这样的写法仍然是错误的。假设节点A在<code>t0</code>时刻<code>on_leader_start(term=1)</code>了，<code>t1</code>时刻变为follower，<code>t2</code>时刻B选为<code>term=2</code>的leader，<code>t3</code>时刻A又选为<code>term=3</code>的leader，<code>t4</code>时刻A才<code>on_leader_stop(term=1)</code>。那么<code>t3~t4</code>内<code>is_leader_lease_valid</code>返回<code>true</code>(<code>term=3</code>的<code>lease</code>)，且<code>_leader_term == 1 &gt; 0</code>，两个条件均满足，于是<code>get</code>请求全都能成功，实际上不应该成功。</p>
<h3 id="正解-校验leader-lease的term与状态机的term是否一致"><a href="#正解-校验leader-lease的term与状态机的term是否一致" class="headerlink" title="正解. 校验leader lease的term与状态机的term是否一致"></a>正解. 校验leader lease的<code>term</code>与状态机的<code>term</code>是否一致</h3><p>事实上，前面两个方案都不满足“状态机足够新”这个前提。</p>
<p>想要实现这个约束，只需要检查leader lease的<code>term</code>与状态机的<code>term</code>是否一致。这是因为在braft中，刚选为leader时就会propose一条<code>no-op</code>日志，当apply到这条日志时，意味着此前所有<code>term</code>的数据都应用到状态机了。如果此时leader lease有效，意味着没有别的leader，新的写入都在自己身上，因此自己的数据一定是最新的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_leader</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    LeaderLeaseStatus lease_status;</span><br><span class="line">    <span class="built_in">get_leader_lease_status</span>(&amp;lease_status);</span><br><span class="line">    <span class="keyword">auto</span> term = _leader_term.<span class="built_in">load</span>(butil::memory_order_acquire);</span><br><span class="line">    <span class="keyword">return</span> term &gt; <span class="number">0</span> &amp;&amp; term == lease_status.term;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tikv</code>也有类似的逻辑。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/tikv/tikv/blob/v5.3.0/components/raftstore/src/store/worker/read.rs#L260-L277</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_in_leader_lease</span></span>(&amp;<span class="keyword">self</span>, ts: Timespec, metrics: &amp;<span class="keyword">mut</span> ReadMetrics) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="keyword">ref</span> lease) = <span class="keyword">self</span>.leader_lease &#123;</span><br><span class="line">        <span class="keyword">let</span> term = lease.term();</span><br><span class="line">        <span class="keyword">if</span> term == <span class="keyword">self</span>.term &#123; <span class="comment">// &lt;--- 校验term相同(这里的self就是状态机)</span></span><br><span class="line">            <span class="keyword">if</span> lease.inspect(<span class="literal">Some</span>(ts)) == LeaseState::Valid &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                metrics.rejected_by_lease_expire += <span class="number">1</span>;</span><br><span class="line">                debug!(<span class="string">&quot;rejected by lease expire&quot;</span>; <span class="string">&quot;tag&quot;</span> =&gt; &amp;<span class="keyword">self</span>.tag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            metrics.rejected_by_term_mismatch += <span class="number">1</span>;</span><br><span class="line">            debug!(<span class="string">&quot;rejected by term mismatch&quot;</span>; <span class="string">&quot;tag&quot;</span> =&gt; &amp;<span class="keyword">self</span>.tag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也许你会问，为什么只需要校验状态机当前的<code>term</code>是否足够新，而不需要校验状态机当前的<code>index</code>是否足够新呢？<br>答案很简单，服务端是在apply完成后才向用户返回成功的，而不是日志commit时就返回成功。因此还未apply的日志还不算写入成功，那么读不到也是应该的。</p>
<p>也许你还会问，如果校验leader lease成功后线程卡住了，过了很久才读取数据，不还是会读到stale data吗？<br>比如这样：</p>
<p><img src="/images/braft-in-action/Linearizability.png" alt="Linearizability"></p>
<p>假设初始时<code>x=1</code>，节点A在<code>t1</code>时刻校验leader lease成功，<code>t2</code>时刻lease失效，随后节点B当选leader，并且在<code>t3</code>时刻<code>propose</code>了一个新值<code>x=2</code>，<code>t4</code>时刻<code>apply</code>成功，<br><code>t5</code>时刻A读取数据。由于<code>t6</code>时刻A才apply <code>x=2</code>，这次读请求会返回旧值<code>x=1</code>。</p>
<p>是的，是会读到旧值，但不违反线性一致性，因为这两个请求并发了。对于并发的读写请求，返回新值还是旧值都是合理的。线性一致性要求的是<code>t4</code>时刻之后，所有<strong>新的</strong>读请求都必须读到<code>x=2</code>而不是<code>x=1</code>。如果再考虑到不少系统采用的是快照读，这个读请求更是只能返回<code>x=1</code>，当然这就不属于Raft的范畴了。</p>
<p>事实上，由于从发送请求到结果返回是需要时间的，读到stale data是不可避免的。即使采用“基本使用姿势”中完全串行化的做法，也会受到网络的影响，导致读请求的结果很晚才到达客户端。</p>
<h2 id="踩坑-follower也会遇到iter-done-NULL"><a href="#踩坑-follower也会遇到iter-done-NULL" class="headerlink" title="踩坑. follower也会遇到iter.done() != NULL"></a>踩坑. follower也会遇到<code>iter.done() != NULL</code></h2><p>braft的接口是异步的，在调用<code>void apply(const Task&amp; task)</code>时，用户可以往<code>task.done</code>里塞入一个<code>Closure</code>回调对象。如果未达成一致，则braft会单独启动一个协程(bthread)调用<code>done-&gt;Run()</code>用以通知调用方。<br>如果达成一致，则braft只会调用<code>on_apply</code>，通过<code>Iterator</code>让用户迭代每条日志，而不会调用<code>done-&gt;Run()</code>，注释是这么说的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line">    <span class="comment">// If done() is non-NULL, you must call done()-&gt;Run() after applying this</span></span><br><span class="line">    <span class="comment">// task no matter this operation succeeds or fails, otherwise the</span></span><br><span class="line">    <span class="comment">// corresponding resources would leak.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If this task is proposed by this Node when it was the leader of this </span></span><br><span class="line">    <span class="comment">// group and the leadership has not changed before this point, done() is </span></span><br><span class="line">    <span class="comment">// exactly what was passed to Node::apply which may stand for some </span></span><br><span class="line">    <span class="comment">// continuation (such as respond to the client) after updating the </span></span><br><span class="line">    <span class="comment">// StateMachine with the given task. Otherweise done() must be NULL.</span></span><br><span class="line">    <span class="function">Closure* <span class="title">done</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译一下，<code>done()</code>如果非空，则用户必须自己调用<code>done()-&gt;Run()</code>；而<code>done()</code>当且仅当 1. 这个<code>task</code>是这个<code>Node</code>还是leader的时候propose的；2. 直到此时leader还没变过 这两个条件都满足时非空。并且它的值就是此前用户往<code>task.done</code>里塞的值。</p>
<p>那很自然，我们会认为<code>on_leader_stop</code>之后的所有<code>iter.done()</code>都是空的。因为此时leader已经stop了，不满足条件2。</p>
<p>然而现实并非如此。对于transfer leader场景，braft会让leader的状态机执行<code>on_leader_stop</code>，如果此时follower发来了<code>AppendEntries</code>成功的回复，则<code>commitIndex</code>将推进，braft又会让leader状态机执行<code>on_apply</code>。于是预期外的状态出现了：明明已经<code>on_leader_stop</code>了，却还有<code>iter.done() != NULL</code>。严格来说这也不算注释有bug，因为此时leader还没有<strong>changed</strong>。</p>
<p>如果你的<code>Run()</code>函数处理逻辑依赖于<code>on_leader_start/on_leader_stop</code>，那你要小心检查是否能正确处理这个情况。</p>
<h2 id="未决日志的处理"><a href="#未决日志的处理" class="headerlink" title="未决日志的处理"></a>未决日志的处理</h2><p>任何分布式系统的请求与响应都有三态：成功、失败、超时(未知)。Raft也不例外，未在用户指定时间内达成一致/apply即属于超时。此时要么选择重试(需要保证幂等)；要么选择死等，等到确定了成功/失败后再进行下一步操作。</p>
<p>除了这种常见的超时导致的未知，还有一种特殊场景的未知。即用户propose了一条日志，当leader(A)已经将该日志在本地落盘，却还未commit时发生了leader切换，此时结果未知：1. 新leader还是A自己，则该日志随着A新写的no-op日志的commit而commit； 2. 该日志还没发给别的follower，新leader不是A自己，则该日志随着新leader的no-op日志commit之后而盖棺定论：它不可能达成一致了；3. 该日志发给了某个follower，新leader是这个follower，则该日志会随着no-op日志的commit而commit。</p>
<p>对于这种场景，braft的处理是直接报错，即单独启动一个协程(bthread)调用<code>done-&gt;Run()</code>用以通知调用方结果未知。这时可以选择让客户端直接重试(同样，需要保证幂等)，也可以选择在服务端死等。等到什么时候呢？等到状态机收到新的no-op日志即可。如果达成一致，则状态机已经apply了用户提交的日志，向用户返回成功即可。</p>
<h2 id="Multi-Raft-带来的随机写"><a href="#Multi-Raft-带来的随机写" class="headerlink" title="Multi-Raft 带来的随机写"></a>Multi-Raft 带来的随机写</h2><p>对于一个分布式系统，能够在一定范围内水平扩展是基本需求。这意味着整个集群必然不能只有一个Raft Group。<br>此外，即使是一个只有3节点的系统，也需要多个Raft Group才能发挥出硬件的全部性能。<br>因为在Raft中只有leader才提供读写服务，也就是其余的两个follower相对空闲。那么只有一个Raft Group的话就意味着两台机器较闲。<br>因此，工程上基本都需要对数据进行分片，每个分片的多个副本组成一个Raft Group，整个系统有多个Raft Group(即Multi-Raft)，从而达到均衡负载的目的。</p>
<p>然而，braft的存储层是<code>per-Node</code>的，每个<code>braft::Node</code>持有一个目录，顺序追加自己的日志。当单台机器上的Raft Group数量较多时，对于IO设备来说就相当于随机写。在我们的机器上实测当组数大于8时，就能观察到明显的吞吐下降。为了解决这个问题，一些其他Raft库直接采用了现成的存储引擎。比如braft的Java移植版<a target="_blank" rel="noopener" href="https://github.com/sofastack/sofa-jraft">sofa-jraft</a>就使用RocksDB；TiKV也是使用RocksDB；<a target="_blank" rel="noopener" href="https://github.com/lni/dragonboat">dragonboat</a>则采用了CockroachDB的<a target="_blank" rel="noopener" href="https://github.com/cockroachdb/pebble">pebble</a>。</p>
<p>而我们的做法则是重写了存储层，不同的Raft Group共用Raft Log，采用单线程组提交的方式实现顺序写。除了避免随机写，和RocksDB比这样做还减少了磁盘IO，这是因为Raft Log需要经常的删除前缀，RocksDB在这种情况下会带来额外的写放大。缺点是Log文件的删除变得相对复杂。比如一个日志文件里大部分的日志都由于做了snapshot而不再需要了，却有某个Group还有少量日志，则这个日志文件仍需要保留，浪费磁盘空间。因此我们也相应开发了log compact的功能。</p>
<h2 id="缓存未apply的日志"><a href="#缓存未apply的日志" class="headerlink" title="缓存未apply的日志"></a>缓存未apply的日志</h2><p>出于性能考虑，braft对于已经commit但还未apply的日志的处理是全部缓存在内存中，预期是这些日志很快就要输入给状态机。这样的做法能够大大减少读盘次数。</p>
<p>然而，这样的缓存策略有bad case。考虑某个follower宕机重启的场景，一方面它需要重新apply一遍宕机前已有的日志，另一方面leader还在不停地给它发送新的日志。如果按照前面所述的策略，此时所有新日志都会被缓存在内存。如果存量日志很多，则这个过程会很长，甚至有可能导致OOM。</p>
<p>解决方法也很直接，加个缓存容量限制即可。简单粗暴的话就设置一个常量n，每个raft node最多缓存n条日志。更精细一些的话可以设置一个进程级别的总限制n，考虑不同raft node的写入量，给写入量大的raft node分配较大的n_i。</p>
<h2 id="全新的Raft-Group尽快提供服务"><a href="#全新的Raft-Group尽快提供服务" class="headerlink" title="全新的Raft Group尽快提供服务"></a>全新的Raft Group尽快提供服务</h2><p>启用了lease机制后，一个新实例化出来的<code>braft::Node</code>要先sleep选举超时时间+最大时钟漂移时间后才会发起选举。在进程宕机重启的场景下，这是必要的，否则有可能违背了对leader lease的承诺。但对于一个全新的Raft Group来说这是完全不必要的——此前必然没有作出过任何承诺。因此可以立刻发起选举，尽快对外提供服务。为此笔者也提了一个pr给braft官方。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文主要介绍了利用braft实现lease read的方式，此外还分享了一些遇到的坑/可以采取的优化。希望对你有帮助: )。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Raft/" rel="tag"># Raft</a>
              <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" rel="tag"># 分布式系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/06/matrixkv/" rel="prev" title="MatrixKV: Reducing Write Stalls and Write Amplification in LSM-tree Based KV Stores with a Matrix Container in NVM">
      <i class="fa fa-chevron-left"></i> MatrixKV: Reducing Write Stalls and Write Amplification in LSM-tree Based KV Stores with a Matrix Container in NVM
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF"><span class="nav-number">1.</span> <span class="nav-text">基本使用姿势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E8%AF%B7%E6%B1%82%E4%BC%98%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">读请求优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%9D%E8%AF%951-%E5%88%A9%E7%94%A8on-leader-start%E6%9D%A5%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.</span> <span class="nav-text">尝试1. 利用on_leader_start来实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%9D%E8%AF%952-%E5%88%A9%E7%94%A8leader-lease%E5%AE%9E%E7%8E%B0lease-read"><span class="nav-number">2.2.</span> <span class="nav-text">尝试2. 利用leader lease实现lease read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E8%A7%A3-%E6%A0%A1%E9%AA%8Cleader-lease%E7%9A%84term%E4%B8%8E%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84term%E6%98%AF%E5%90%A6%E4%B8%80%E8%87%B4"><span class="nav-number">2.3.</span> <span class="nav-text">正解. 校验leader lease的term与状态机的term是否一致</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B8%A9%E5%9D%91-follower%E4%B9%9F%E4%BC%9A%E9%81%87%E5%88%B0iter-done-NULL"><span class="nav-number">3.</span> <span class="nav-text">踩坑. follower也会遇到iter.done() !&#x3D; NULL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AA%E5%86%B3%E6%97%A5%E5%BF%97%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">未决日志的处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Multi-Raft-%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%9A%8F%E6%9C%BA%E5%86%99"><span class="nav-number">5.</span> <span class="nav-text">Multi-Raft 带来的随机写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%9C%AAapply%E7%9A%84%E6%97%A5%E5%BF%97"><span class="nav-number">6.</span> <span class="nav-text">缓存未apply的日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E6%96%B0%E7%9A%84Raft-Group%E5%B0%BD%E5%BF%AB%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1"><span class="nav-number">7.</span> <span class="nav-text">全新的Raft Group尽快提供服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-number">8.</span> <span class="nav-text">结语</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yriuns</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Yriuns" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yriuns" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-bug"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yriuns</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '117937fd5d0fa0f067c8',
      clientSecret: 'f405a61a81d7d16364eb79f2351f1a72f49db3b4',
      repo        : 'gitalk',
      owner       : 'Yriuns',
      admin       : ['Yriuns'],
      id          : '6ef6115742e2819ee93d906f2e2e9727',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
